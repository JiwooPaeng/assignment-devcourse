# 객제 지향 프로그래밍
기능 단위가 객체이기 때문에 결합과 분리가 쉽고 유연하다 <br>
cf) 구조적, 하향식 프로그래밍 (기능단위 함수)

# 클래스
사용자 정의 데이터 타입 → 추상적 **데이터타입**
- 데이터 타입이기에 변수로 선언해서 사용 → 클래스를 통해 선언한 변수가 **객체**
- 구조체와 비슷
- **멤버 변수**와 **멤버 함수**로 구성 <br>

**형식**
```
class 클래스 이름 {
  접근지정자 데이터형 멤버변수 / 메서드
}
```
## 접근 지정자
- private : 클래스 내부에서만 접근 가능하나, 외부에서는 접근 불가 → 캡슐화
- public : 누구나 접근 가능
- protected : 클래스 내부에서만 접근 가능하지만, 자식은 접근 가능

## 생성자
constructor <br>
객체 생성시 제공되는 초기화 전용 메서드 (자동으로 호출)
- 클래스의 이름과 동일한 이름을 작성
```c#
class Dog {
    private int eyes, nose, mouse, ears;
    // 생성자
    public Dog() {
        eye = 0;
        nose = 0;
        mouse = 0;
        ears = 0;
    }
}
```

<br>

# 객체 지향 철학

## 추상화
대상에서 관념적인 특징만을 뽑아낸 것 <br> 
> 특성을 정리하여 필드와 메서드로 표현하는 과정


## 캡슐화
외부에서 내부를 볼 수 없게 한다는 의미, 하지만 숨기기만 해서는 안된다 → 인터페이스를 통해 조작
> 추상화된 결과를 하나의 클래스에 포함시키고 스스로 보호하는 것


## 상속성
이미 완성된 클래스를 다른 클래스에 상속할 수 있다 (extends) → 공통적인 속성으로 사용 가능


## 다형성
오버로딩, 오버라이딩 <br>
함수의 이름이 같더라도 전달 인자의 타입이나 개우세 따라 구분
> 얼핏 보면 같지만 자세히 보면 다르다!

### 오버로딩
겉모습은 같지만 내용이 다른 경우 <br>
이름이 같은 함수일지라도 전달인자 타입 or 개수가 달라 다른 함수로 인식하는 경우

### 오버라이딩
상속의 개념 기반 <br>
부모 클래스의 메서드를 재작성해서 변경할 수 있다